/// <reference types="node" />
import type { OutgoingLogBody } from './metrics-log';
import type { IncomingMessage, ServerResponse } from 'node:http';
/**
 * Extracts the protocol string from the incoming request
 *
 * @param req
 * @returns
 */
export declare function getProto(req: IncomingMessage): 'https' | 'http';
export interface LogOptions {
    /**
     * An array of values to include in the incoming and outgoing headers, parameters and body;
     * everything else will be redacted.
     *
     * If set, the denylist will be ignored.
     */
    allowlist?: string[];
    /**
     * @deprecated use `denylist` instead
     */
    blacklist?: string[];
    /**
     * An array of values to redact from the incoming and outgoing headers, parameters and body.
     */
    denylist?: string[];
    /**
     * If true, the logs will be marked as development logs.
     */
    development?: boolean;
    /**
     * If true, this will return the log details without waiting for a response from the Metrics
     * servers.
     */
    fireAndForget?: boolean;
    /**
     * @deprecated use `allowList` instead
     */
    whitelist?: string[];
}
export interface PayloadData {
    /**
     * API Key used to make the request. Note that this is different from the `readmeAPIKey`
     * described above and should be a value from your API that is unique to each of your users.
     */
    apiKey: string;
    /**
     * Email of the user that is making the call
     */
    email?: string;
    /**
     * This will be the user's display name in the API Metrics Dashboard, since it's much easier to
     * remember a name than an API key.
     */
    label?: string;
    /**
     * A UUIDv4 identifier. If not provided this will be automatically generated for you. You can use
     * this ID in conjunction with your `base_url` to create the URL that points to this log.
     *
     * @example {base_url}/logs/{logId}
     */
    logId?: string;
    /**
     * Object or string | The incoming request body. You should provide this function a parsed object,
     * but a string is acceptable if necessary.
     */
    requestBody?: Record<string, unknown> | string;
    /**
     * The outgoing request body as a string.
     */
    responseBody?: string;
    /**
     * A JavaScript `Date` object representing the time the server finished sending the outgoing
     * response.
     */
    responseEndDateTime: Date;
    /**
     * If provided this path will be used instead of the request path. This is useful for grouping
     * common routes together as `/users/{user_id}` instead of each page being unique as `/users/1`,
     * `/users/2`, etc.
     */
    routePath?: string;
    /**
     * A JavaScript `Date` object representing the time the server received the incoming request.
     * This should be logged before retrieving and parsing the incoming request body.
     */
    startedDateTime: Date;
}
/**
 * This will generate an integrity hash that looks something like this:
 *
 * sha512-Naxska/M1INY/thefLQ49sExJ8E+89Q2bz/nC4Pet52iSRPtI9w3Cyg0QdZExt0uUbbnfMJZ0qTabiLJxw6Wrg==?1345
 *
 * With the last 4 digits on the end for us to use to identify it later in a list.
 */
export declare function mask(apiKey: any): string;
export declare function constructPayload(req: IncomingMessage, res: ServerResponse, payloadData: PayloadData, logOptions: LogOptions): OutgoingLogBody;
